{
  "imageDecryptEval": "const pageLinks = []; const dTfnTRegex = /dTfnT\\([^,]+,[^,]+,[^,]+,[^,]+,[^,]+,(_[^\\s,]+)\\s*,\\s*[^,]+,\\s*['\"]([^'\"]+)['\"]/g; const matches = [..._encryptedString.matchAll(dTfnTRegex)]; function step1(s){ return s.substring(15, 15 + 18) + s.substring(15 + 18 + 17); } function step2(s){ return s.substring(0, s.length - 11) + s[s.length - 2] + s[s.length - 1]; } function isProbablyBase64(s){ return /^[A-Za-z0-9+/=_-]+$/.test(s); } function normalizeBase64Url(s){ // convert URL-safe base64 to normal base64 and pad if needed\n    let t = s.replace(/-/g, '+').replace(/_/g, '/'); const mod = t.length % 4; if(mod === 2) t += '=='; else if(mod === 3) t += '='; else if(mod === 1) return null; return t; } function base64ToUtf8(b64){ try{ const norm = normalizeBase64Url(b64); if(!norm) return null; const bin = atob(norm); const bytes = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i); try{ return new TextDecoder('utf-8').decode(bytes); }catch(e){ // fallback to binary->latin1 style string\n        let out=''; for(let i=0;i<bytes.length;i++) out += String.fromCharCode(bytes[i]); return out; } }catch(e){return null;} } function safeReplaceTokens(s){ if(!s) return s; // only replace exact token sequences, never single letters\n    return s.replace(/Vd__xGEvMo_/g,'g').replace(/pw_\\.g28x/g,'b').replace(/d2pr\\.x_27/g,'h'); } function decryptLink(t){ if(!t) return ''; let e = t.trim(); // already final form: starts with 'pw/' or 'AP' (observed pattern)\n    if(e.startsWith('pw/') || e.startsWith('AP')){ if(!e.startsWith('pw/')) e = 'pw/' + e; return 'https://2.bp.blogspot.com/' + e; } // apply token replacements (only full tokens)\n    e = e.replace(/Vd__xGEvMo_/g,'g').replace(/pw_\\.g28x/g,'b').replace(/d2pr\\.x_27/g,'h'); const qIdx = e.indexOf('?'); const query = qIdx !== -1 ? e.substring(qIdx) : ''; const body = qIdx !== -1 ? e.substring(0, qIdx) : e; const hasS0 = body.includes('=s0?'); const endIdx = hasS0 ? body.indexOf('=s0?') : body.indexOf('=s1600?'); let enc = body.substring(0, endIdx !== -1 ? endIdx : body.length); // apply step transforms\n    enc = step1(enc); enc = step2(enc); // if enc doesn't look like base64, assume it's already the id\n    if(!isProbablyBase64(enc)) { // still ensure prefix\n        if(!enc.startsWith('pw/')) enc = 'pw/' + enc; return 'https://2.bp.blogspot.com/' + enc + query; } // convert and decode base64 (handle URL-safe)\n    const text = base64ToUtf8(enc); if(!text || text.length < 10) return ''; const cleaned = text.substring(0,13) + text.substring(17); const final = cleaned.substring(0, cleaned.length - 2) + (hasS0 ? '=s0' : '=s1600'); return 'https://2.bp.blogspot.com/pw/' + final + query; } matches.forEach(m => { try{ if(m[2] && m[2].length > 12){ const extracted = m[2].substring(12); const link = decryptLink(extracted); if(link) pageLinks.push(link); } }catch(e){} }); JSON.stringify(pageLinks);",
  "postDecryptEval": null,
  "shouldVerifyLinks": false
}
